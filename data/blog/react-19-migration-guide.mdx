---
title: "React 19 Migration Guide: Complete Upgrade from React 18"
date: "2025-09-15"
tags: ["React", "React 19", "Migration", "Upgrade", "JavaScript", "Next.js", "TypeScript"]
draft: false
summary: "Complete step-by-step guide to migrate from React 18 to React 19. Handle breaking changes, adopt new features, and ensure smooth transition with practical examples and troubleshooting."
---

# React 19 Migration Guide: Complete Upgrade from React 18

React 19 brings significant improvements in performance, developer experience, and new features. This comprehensive migration guide will walk you through upgrading from React 18 to React 19 step by step, with practical examples and troubleshooting tips.

---

title: "React 19 Migration Guide: Complete Upgrade from React 18"
date: "2025-09-15"
tags: ["React", "React 19", "Migration", "Upgrade", "JavaScript", "Next.js", "TypeScript"]
draft: false
summary: "Complete step-by-step guide to migrate from React 18 to React 19. Handle breaking changes, adopt new features, and ensure smooth transition with practical examples and troubleshooting."

---

# React 19 Migration Guide: Complete Upgrade from React 18

React 19 brings significant improvements in performance, developer experience, and new features. This comprehensive migration guide will walk you through upgrading from React 18 to React 19 step by step, with practical examples and troubleshooting tips.

## üìã Migration Overview

### What's New in React 19

- **Server Components**: Render components on the server for better performance
- **useOptimistic**: Optimistic UI updates for better user experience
- **useDeferredValue & useTransition**: Enhanced concurrent rendering
- **Enhanced Forms**: Better form handling with validation
- **Compiler Improvements**: Automatic optimizations
- **Better TypeScript Support**: Improved type inference

### Breaking Changes

- Some deprecated APIs removed
- Concurrent features enabled by default
- Changes to error handling
- Updates to React DOM APIs

## üîç Pre-Migration Assessment

### Step 1: Check Your Current Setup

```bash
# Check your current React version
npm list react react-dom

# Check for deprecated patterns
npx @next/codemod --help

# Analyze your codebase for potential issues
npx @typescript-eslint/parser --version
```

### Step 2: Backup Your Project

```bash
# Create a backup branch
git checkout -b migration-backup
git add .
git commit -m "Backup before React 19 migration"

# Create a new migration branch
git checkout -b react-19-migration

# Optional: Create a separate branch for testing
git checkout -b react-19-testing
```

### Step 3: Update Dependencies

```bash
# Update React and React DOM
npm install react@latest react-dom@latest

# Update related packages
npm install @types/react@latest @types/react-dom@latest

# Update testing libraries if needed
npm install @testing-library/react@latest @testing-library/jest-dom@latest

# Update build tools
npm install next@latest # if using Next.js
npm install vite@latest # if using Vite

# Update ESLint and TypeScript
npm install eslint@latest @typescript-eslint/parser@latest @typescript-eslint/eslint-plugin@latest
```

## üöÄ Step-by-Step Migration Process

### Phase 1: Core Dependencies Update

#### 1.1 Update package.json

```json
{
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "^15.0.0" // if applicable
  },
  "devDependencies": {
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "typescript": "^5.6.0", // if using TypeScript
    "eslint": "^9.0.0",
    "@typescript-eslint/parser": "^8.0.0",
    "@typescript-eslint/eslint-plugin": "^8.0.0"
  }
}
```

#### 1.2 Install Updates

```bash
npm install

# Clean node_modules and reinstall if issues occur
rm -rf node_modules package-lock.json
npm install
```

#### 1.3 Handle TypeScript Updates

If you're using TypeScript, update your `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["DOM", "DOM.Iterable", "ES6"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "incremental": true,
    "tsBuildInfoFile": "node_modules/.cache/tsconfig.tsbuildinfo"
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

#### 1.4 Update ESLint Configuration

```javascript
// .eslintrc.js or eslint.config.js
module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    "eslint:recommended",
    "@typescript-eslint/recommended",
    "plugin:react/recommended",
    "plugin:react/jsx-runtime",
    "plugin:react-hooks/recommended",
  ],
  ignorePatterns: ["dist", ".eslintrc.cjs"],
  parser: "@typescript-eslint/parser",
  plugins: ["react-refresh"],
  rules: {
    "react-refresh/only-export-components": ["warn", { allowConstantExport: true }],
  },
};
```

### Phase 2: Handle Breaking Changes

#### 2.1 React.StrictMode Changes

React 19 enables concurrent features by default. Update your root component:

```jsx
// Before (React 18)
import { StrictMode } from "react";

function App() {
  return (
    <StrictMode>
      <MyApp />
    </StrictMode>
  );
}

// After (React 19) - Concurrent features enabled by default
import { StrictMode } from "react";

function App() {
  return (
    <StrictMode>
      <MyApp />
    </StrictMode>
  );
}
```

#### 2.2 useEffect Cleanup Function Changes

React 19 is stricter about cleanup functions:

```jsx
// Before (React 18)
useEffect(() => {
  const timer = setTimeout(() => {
    console.log("Done!");
  }, 1000);

  return () => {
    clearTimeout(timer);
  };
}, []);

// After (React 19) - Same, but stricter enforcement
useEffect(() => {
  const timer = setTimeout(() => {
    console.log("Done!");
  }, 1000);

  return () => {
    clearTimeout(timer);
  };
}, []);

// Enhanced cleanup pattern for React 19
useEffect(() => {
  let isMounted = true;

  const fetchData = async () => {
    try {
      const response = await fetch("/api/data");
      if (isMounted) {
        const data = await response.json();
        setData(data);
      }
    } catch (error) {
      if (isMounted) {
        setError(error);
      }
    }
  };

  fetchData();

  return () => {
    isMounted = false;
  };
}, []);
```

#### 2.3 Error Boundary Updates

Error boundaries work the same but with better error information:

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // React 19 provides more detailed errorInfo
    console.error("Error caught by boundary:", error, errorInfo);

    // Log to error reporting service
    if (typeof window !== "undefined" && window.errorReporter) {
      window.errorReporter.captureException(error, {
        extra: {
          componentStack: errorInfo.componentStack,
          errorBoundary: this.props.name || "Unknown",
        },
      });
    }

    this.setState({
      error,
      errorInfo,
    });
  }

  handleRetry = () => {
    this.setState({ hasError: false, error: null, errorInfo: null });
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong</h2>
          <details>
            <summary>Error Details (Development)</summary>
            <pre>{this.state.error && this.state.error.toString()}</pre>
            <pre>{this.state.errorInfo.componentStack}</pre>
          </details>
          <button onClick={this.handleRetry}>Try Again</button>
        </div>
      );
    }

    return this.props.children;
  }
}

// Usage with error boundary
function App() {
  return (
    <ErrorBoundary name="App">
      <Header />
      <ErrorBoundary name="MainContent">
        <MainContent />
      </ErrorBoundary>
      <Footer />
    </ErrorBoundary>
  );
}
```

### Phase 3: Adopt New Features

#### 3.1 Implement useOptimistic

Replace manual optimistic updates with the new hook:

```jsx
// Before (React 18) - Manual optimistic updates
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [isAdding, setIsAdding] = useState(false);

  const addTodo = async (text) => {
    setIsAdding(true);
    const tempId = Date.now();
    const optimisticTodo = { id: tempId, text, completed: false };

    // Optimistic update
    setTodos((prev) => [...prev, optimisticTodo]);

    try {
      const newTodo = await api.addTodo(text);
      // Replace optimistic with real data
      setTodos((prev) => prev.map((todo) => (todo.id === tempId ? newTodo : todo)));
    } catch (error) {
      // Revert on error
      setTodos((prev) => prev.filter((todo) => todo.id !== tempId));
      console.error("Failed to add todo:", error);
    } finally {
      setIsAdding(false);
    }
  };

  return (
    <div>
      <input value={text} onChange={(e) => setText(e.target.value)} disabled={isAdding} />
      <button onClick={() => addTodo(text)} disabled={isAdding}>
        {isAdding ? "Adding..." : "Add Todo"}
      </button>
      <ul>
        {todos.map((todo) => (
          <li key={todo.id}>{todo.text}</li>
        ))}
      </ul>
    </div>
  );
}

// After (React 19) - useOptimistic hook
import { useOptimistic } from "react";

function TodoList() {
  const [todos, setTodos] = useState([]);
  const [optimisticTodos, setOptimisticTodos] = useOptimistic(todos);

  const addTodo = async (text) => {
    const optimisticTodo = {
      id: Date.now(),
      text,
      completed: false,
      isOptimistic: true,
    };

    // Add optimistic update
    setOptimisticTodos((prev) => [...prev, optimisticTodo]);

    try {
      const newTodo = await api.addTodo(text);
      // Replace with real data
      setTodos((prev) => [...prev, newTodo]);
    } catch (error) {
      // Remove optimistic update on error
      setOptimisticTodos((prev) => prev.filter((todo) => todo.id !== optimisticTodo.id));
      console.error("Failed to add todo:", error);
    }
  };

  return (
    <div>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => addTodo(text)}>Add Todo</button>
      <ul>
        {optimisticTodos.map((todo) => (
          <li
            key={todo.id}
            style={{
              opacity: todo.isOptimistic ? 0.7 : 1,
              fontStyle: todo.isOptimistic ? "italic" : "normal",
            }}
          >
            {todo.text}
            {todo.isOptimistic && " (saving...)"}
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#### 3.2 Use useDeferredValue for Performance

```jsx
// Before (React 18) - Blocking search
function SearchComponent({ data }) {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState([]);

  useEffect(() => {
    const filtered = data.filter((item) => item.name.toLowerCase().includes(query.toLowerCase()));
    setResults(filtered);
  }, [query, data]);

  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} placeholder="Search..." />
      <ResultsList results={results} />
    </div>
  );
}

// After (React 19) - Non-blocking search with useDeferredValue
import { useDeferredValue, useMemo } from "react";

function SearchComponent({ data }) {
  const [query, setQuery] = useState("");
  const deferredQuery = useDeferredValue(query);

  const results = useMemo(() => {
    // Expensive operation uses deferred value
    return data.filter((item) => item.name.toLowerCase().includes(deferredQuery.toLowerCase()));
  }, [deferredQuery, data]);

  const isStale = query !== deferredQuery;

  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} placeholder="Search..." />

      {/* Show current query immediately */}
      <div>Searching for: "{query}"</div>

      {/* Show stale indicator */}
      {isStale && <div style={{ color: "orange" }}>Updating results for "{query}"...</div>}

      <ResultsList results={results} />
    </div>
  );
}

// Advanced search with multiple deferred values
function AdvancedSearch({ data }) {
  const [query, setQuery] = useState("");
  const [filters, setFilters] = useState({});
  const [sortBy, setSortBy] = useState("name");

  // Defer expensive operations
  const deferredQuery = useDeferredValue(query);
  const deferredFilters = useDeferredValue(filters);
  const deferredSortBy = useDeferredValue(sortBy);

  const processedResults = useMemo(() => {
    let results = data;

    // Apply search filter
    if (deferredQuery) {
      results = results.filter((item) =>
        item.name.toLowerCase().includes(deferredQuery.toLowerCase())
      );
    }

    // Apply additional filters
    Object.entries(deferredFilters).forEach(([key, value]) => {
      if (value) {
        results = results.filter((item) => item[key] === value);
      }
    });

    // Apply sorting
    results.sort((a, b) => {
      if (deferredSortBy === "name") {
        return a.name.localeCompare(b.name);
      }
      return a[deferredSortBy] - b[deferredSortBy];
    });

    return results;
  }, [data, deferredQuery, deferredFilters, deferredSortBy]);

  const isStale =
    query !== deferredQuery ||
    JSON.stringify(filters) !== JSON.stringify(deferredFilters) ||
    sortBy !== deferredSortBy;

  return (
    <div>
      <SearchInput value={query} onChange={setQuery} />
      <FilterControls filters={filters} onChange={setFilters} />
      <SortControls value={sortBy} onChange={setSortBy} />

      {isStale && <div>Processing...</div>}

      <ResultsList results={processedResults} />
    </div>
  );
}
```

#### 3.3 Implement useTransition

```jsx
// Before (React 18) - Manual loading states
function TabComponent({ tabs }) {
  const [activeTab, setActiveTab] = useState(0);
  const [isLoading, setIsLoading] = useState(false);

  const switchTab = async (index) => {
    setIsLoading(true);
    await new Promise((resolve) => setTimeout(resolve, 100)); // Simulate loading
    setActiveTab(index);
    setIsLoading(false);
  };

  return (
    <div>
      {tabs.map((tab, index) => (
        <button key={index} onClick={() => switchTab(index)} disabled={isLoading}>
          {tab.title}
        </button>
      ))}
      {isLoading ? <div>Loading...</div> : <TabContent content={tabs[activeTab].content} />}
    </div>
  );
}

// After (React 19) - useTransition for smooth transitions
import { useTransition } from "react";

function TabComponent({ tabs }) {
  const [activeTab, setActiveTab] = useState(0);
  const [isPending, startTransition] = useTransition();

  const switchTab = (index) => {
    startTransition(() => {
      setActiveTab(index);
    });
  };

  return (
    <div>
      {tabs.map((tab, index) => (
        <button key={index} onClick={() => switchTab(index)} disabled={isPending}>
          {tab.title}
          {isPending && activeTab === index && " (Loading...)"}
        </button>
      ))}

      <Suspense fallback={<TabSkeleton />}>
        <TabContent content={tabs[activeTab].content} />
      </Suspense>
    </div>
  );
}

// Advanced useTransition with multiple concurrent operations
function DataDashboard() {
  const [data, setData] = useState(null);
  const [filters, setFilters] = useState({});
  const [sortConfig, setSortConfig] = useState(null);

  const [isPending, startTransition] = useTransition();

  const updateFilters = (newFilters) => {
    startTransition(() => {
      setFilters(newFilters);
    });
  };

  const updateSort = (newSort) => {
    startTransition(() => {
      setSortConfig(newSort);
    });
  };

  const refreshData = () => {
    startTransition(async () => {
      const newData = await fetchDashboardData();
      setData(newData);
    });
  };

  return (
    <div>
      <div className="controls">
        <FilterPanel filters={filters} onChange={updateFilters} disabled={isPending} />
        <SortPanel config={sortConfig} onChange={updateSort} disabled={isPending} />
        <button onClick={refreshData} disabled={isPending}>
          {isPending ? "Refreshing..." : "Refresh Data"}
        </button>
      </div>

      {isPending && <div className="loading-overlay">Updating...</div>}

      <DashboardContent data={data} filters={filters} sortConfig={sortConfig} />
    </div>
  );
}
```

### Phase 4: Update Testing

#### 4.1 Update Test Files

```jsx
// Update test imports
import { render, screen, waitFor, fireEvent, act } from "@testing-library/react";
import { useOptimistic, useDeferredValue, useTransition } from "react";

// Test useOptimistic
describe("useOptimistic", () => {
  test("optimistic updates work correctly", async () => {
    const TestComponent = () => {
      const [state, setState] = useState("initial");
      const [optimisticState, setOptimisticState] = useOptimistic(state);

      const handleUpdate = () => {
        setOptimisticState("updated");
        // Simulate async operation
        setTimeout(() => setState("updated"), 100);
      };

      return (
        <div>
          <div data-testid="optimistic">{optimisticState}</div>
          <div data-testid="actual">{state}</div>
          <button onClick={handleUpdate}>Update</button>
        </div>
      );
    };

    render(<TestComponent />);

    expect(screen.getByTestId("optimistic")).toHaveTextContent("initial");
    expect(screen.getByTestId("actual")).toHaveTextContent("initial");

    fireEvent.click(screen.getByText("Update"));

    // Optimistic update should be immediate
    expect(screen.getByTestId("optimistic")).toHaveTextContent("updated");
    expect(screen.getByTestId("actual")).toHaveTextContent("initial");

    // Wait for actual update
    await waitFor(() => {
      expect(screen.getByTestId("actual")).toHaveTextContent("updated");
    });
  });

  test("reverts optimistic update on error", async () => {
    const TestComponent = () => {
      const [state, setState] = useState("initial");
      const [optimisticState, setOptimisticState] = useOptimistic(state);

      const handleFailingUpdate = () => {
        setOptimisticState("updated");
        // Simulate failed operation
        setTimeout(() => {
          setOptimisticState("initial"); // Revert
        }, 100);
      };

      return (
        <div>
          <div data-testid="optimistic">{optimisticState}</div>
          <button onClick={handleFailingUpdate}>Failing Update</button>
        </div>
      );
    };

    render(<TestComponent />);

    fireEvent.click(screen.getByText("Failing Update"));
    expect(screen.getByTestId("optimistic")).toHaveTextContent("updated");

    await waitFor(() => {
      expect(screen.getByTestId("optimistic")).toHaveTextContent("initial");
    });
  });
});

// Test useDeferredValue
describe("useDeferredValue", () => {
  test("deferred value updates correctly", async () => {
    const TestComponent = ({ value }) => {
      const deferredValue = useDeferredValue(value);
      return (
        <div>
          <div data-testid="current">{value}</div>
          <div data-testid="deferred">{deferredValue}</div>
        </div>
      );
    };

    const { rerender } = render(<TestComponent value="initial" />);

    expect(screen.getByTestId("current")).toHaveTextContent("initial");
    expect(screen.getByTestId("deferred")).toHaveTextContent("initial");

    // Update value
    rerender(<TestComponent value="updated" />);

    // Current value updates immediately
    expect(screen.getByTestId("current")).toHaveTextContent("updated");

    // Deferred value might still be old initially
    // In a real test, you might need to wait for the next tick
    await act(async () => {
      await new Promise((resolve) => setTimeout(resolve, 0));
    });

    expect(screen.getByTestId("deferred")).toHaveTextContent("updated");
  });

  test("shows stale state correctly", () => {
    const TestComponent = ({ value }) => {
      const deferredValue = useDeferredValue(value);
      const isStale = value !== deferredValue;

      return (
        <div>
          <div data-testid="stale">{isStale ? "stale" : "fresh"}</div>
        </div>
      );
    };

    const { rerender } = render(<TestComponent value="initial" />);
    expect(screen.getByTestId("stale")).toHaveTextContent("fresh");

    rerender(<TestComponent value="updated" />);
    // Initially stale
    expect(screen.getByTestId("stale")).toHaveTextContent("stale");
  });
});

// Test useTransition
describe("useTransition", () => {
  test("provides loading state during transitions", async () => {
    const TestComponent = () => {
      const [count, setCount] = useState(0);
      const [isPending, startTransition] = useTransition();

      const handleClick = () => {
        startTransition(() => {
          setCount((c) => c + 1);
        });
      };

      return (
        <div>
          <button onClick={handleClick}>Increment</button>
          <div data-testid="count">{count}</div>
          <div data-testid="pending">{isPending ? "pending" : "idle"}</div>
        </div>
      );
    };

    render(<TestComponent />);

    expect(screen.getByTestId("count")).toHaveTextContent("0");
    expect(screen.getByTestId("pending")).toHaveTextContent("idle");

    fireEvent.click(screen.getByText("Increment"));

    // Should show pending state
    expect(screen.getByTestId("pending")).toHaveTextContent("pending");

    // Wait for transition to complete
    await waitFor(() => {
      expect(screen.getByTestId("count")).toHaveTextContent("1");
      expect(screen.getByTestId("pending")).toHaveTextContent("idle");
    });
  });

  test("handles multiple concurrent transitions", async () => {
    const TestComponent = () => {
      const [value, setValue] = useState("");
      const [isPending, startTransition] = useTransition();

      const handleChange = (newValue) => {
        startTransition(() => {
          setValue(newValue);
        });
      };

      return (
        <div>
          <input data-testid="input" value={value} onChange={(e) => handleChange(e.target.value)} />
          <div data-testid="pending">{isPending ? "updating" : "ready"}</div>
        </div>
      );
    };

    render(<TestComponent />);

    const input = screen.getByTestId("input");

    // Rapid typing should trigger pending state
    fireEvent.change(input, { target: { value: "h" } });
    fireEvent.change(input, { target: { value: "he" } });
    fireEvent.change(input, { target: { value: "hel" } });
    fireEvent.change(input, { target: { value: "hell" } });
    fireEvent.change(input, { target: { value: "hello" } });

    expect(screen.getByTestId("pending")).toHaveTextContent("updating");

    await waitFor(() => {
      expect(screen.getByTestId("input")).toHaveValue("hello");
      expect(screen.getByTestId("pending")).toHaveTextContent("ready");
    });
  });
});

// Integration tests
describe("React 19 Integration", () => {
  test("complex interaction with multiple hooks", async () => {
    const ComplexComponent = () => {
      const [query, setQuery] = useState("");
      const [optimisticQuery, setOptimisticQuery] = useOptimistic(query);
      const deferredQuery = useDeferredValue(optimisticQuery);
      const [isPending, startTransition] = useTransition();

      const results = useMemo(() => {
        return ["apple", "banana", "cherry"].filter((item) => item.includes(deferredQuery));
      }, [deferredQuery]);

      const handleSearch = (newQuery) => {
        setOptimisticQuery(newQuery);
        startTransition(() => {
          setQuery(newQuery);
        });
      };

      return (
        <div>
          <input
            data-testid="search"
            value={query}
            onChange={(e) => handleSearch(e.target.value)}
          />
          <div data-testid="pending">{isPending ? "searching" : "ready"}</div>
          <ul data-testid="results">
            {results.map((item) => (
              <li key={item}>{item}</li>
            ))}
          </ul>
        </div>
      );
    };

    render(<ComplexComponent />);

    const searchInput = screen.getByTestId("search");

    fireEvent.change(searchInput, { target: { value: "a" } });

    expect(screen.getByTestId("pending")).toHaveTextContent("searching");

    await waitFor(() => {
      expect(screen.getByTestId("results")).toHaveTextContent("apple");
      expect(screen.getByTestId("results")).toHaveTextContent("banana");
      expect(screen.getByTestId("pending")).toHaveTextContent("ready");
    });
  });
});
```

#### 4.2 Update Jest Configuration

```javascript
// jest.config.js
module.exports = {
  testEnvironment: "jsdom",
  setupFilesAfterEnv: ["<rootDir>/src/setupTests.js"],
  testMatch: [
    "<rootDir>/src/**/__tests__/**/*.{js,jsx,ts,tsx}",
    "<rootDir>/src/**/*.{test,spec}.{js,jsx,ts,tsx}",
  ],
  moduleNameMapping: {
    "^@/(.*)$": "<rootDir>/src/$1",
  },
  transform: {
    "^.+\\.(js|jsx|ts|tsx)$": ["babel-jest", { presets: ["next/babel"] }],
  },
  collectCoverageFrom: ["src/**/*.{js,jsx,ts,tsx}", "!src/**/*.d.ts"],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80,
    },
  },
};
```

#### 4.3 Update Testing Library Setup

```javascript
// src/setupTests.js
import "@testing-library/jest-dom";

// Mock fetch for API calls
global.fetch = jest.fn();

// Mock ResizeObserver
global.ResizeObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn(),
}));

// Mock IntersectionObserver
global.IntersectionObserver = jest.fn().mockImplementation(() => ({
  observe: jest.fn(),
  unobserve: jest.fn(),
  disconnect: jest.fn(),
}));

// Cleanup after each test
afterEach(() => {
  jest.clearAllMocks();
});
```

### Phase 5: Performance Optimization

#### 5.1 Enable React Compiler (Experimental)

```jsx
// next.config.js (for Next.js)
module.exports = {
  experimental: {
    reactCompiler: true,
  },
};

// For Vite
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [
    react({
      babel: {
        plugins: [['babel-plugin-react-compiler', {}]],
      },
    }),
  ],
});

// For Create React App
// Add to package.json
{
  "babel": {
    "plugins": [["babel-plugin-react-compiler", {}]]
  }
}
```

#### 5.2 Optimize Bundle Size

```bash
# Analyze bundle size
npm install --save-dev webpack-bundle-analyzer
npx webpack-bundle-analyzer dist/static/js/*.js

# Check for unused dependencies
npm install --save-dev depcheck
npx depcheck

# Optimize React imports
// Instead of: import React from 'react'
// Use: import { useState } from 'react'
```

#### 5.3 Update Performance Monitoring

```jsx
// Add performance monitoring
import { useEffect } from "react";

function PerformanceMonitor() {
  useEffect(() => {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === "measure") {
          console.log(`${entry.name}: ${entry.duration}ms`);
        }
      }
    });

    observer.observe({ entryTypes: ["measure"] });

    return () => observer.disconnect();
  }, []);

  return null;
}

// Web Vitals monitoring
function WebVitalsMonitor() {
  useEffect(() => {
    import("web-vitals").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(console.log);
      getFID(console.log);
      getFCP(console.log);
      getLCP(console.log);
      getTTFB(console.log);
    });
  }, []);

  return null;
}

// Usage in App
function App() {
  return (
    <div>
      <PerformanceMonitor />
      <WebVitalsMonitor />
      {/* Your app content */}
    </div>
  );
}
```

#### 5.4 Optimize for Concurrent Rendering

```jsx
// Optimize components for concurrent rendering
function OptimizedList({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={item.id} style={{ contain: "layout" }}>
          <Suspense fallback={<ItemSkeleton />}>
            <ListItem item={item} priority={index < 5 ? "high" : "low"} />
          </Suspense>
        </li>
      ))}
    </ul>
  );
}

// Use React.memo for expensive components
const ExpensiveComponent = React.memo(({ data, onUpdate }) => {
  const processedData = useMemo(() => {
    return expensiveComputation(data);
  }, [data]);

  return <div>{processedData}</div>;
});

// Optimize context usage
const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  const contextValue = useMemo(
    () => ({
      theme,
      setTheme,
    }),
    [theme]
  );

  return <ThemeContext.Provider value={contextValue}>{children}</ThemeContext.Provider>;
}
```

## üîß Troubleshooting Common Issues

### Issue 1: Hydration Mismatches

**Problem**: Server and client rendering don't match.

**Solution**:

```jsx
// Use useEffect for client-only code
function ClientOnlyComponent() {
  const [isClient, setIsClient] = useState(false);
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setIsClient(true);
    setMounted(true);
  }, []);

  if (!mounted) {
    return <div>Loading...</div>; // or skeleton
  }

  return <div>Client-only content</div>;
}

// For dynamic content that changes
function DynamicContent({ serverData }) {
  const [clientData, setClientData] = useState(serverData);

  useEffect(() => {
    // Fetch fresh data on client
    fetchFreshData().then(setClientData);
  }, []);

  return <div>{clientData}</div>;
}
```

### Issue 2: useLayoutEffect Warnings

**Problem**: useLayoutEffect doesn't work on server.

**Solution**:

```jsx
import { useEffect, useLayoutEffect } from "react";

function useIsomorphicLayoutEffect() {
  return typeof window !== "undefined" ? useLayoutEffect : useEffect;
}

function MyComponent() {
  const isomorphicLayoutEffect = useIsomorphicLayoutEffect();

  isomorphicLayoutEffect(() => {
    // Your layout effect code
  }, []);
}

// Or conditionally use different hooks
function MyComponent() {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  useLayoutEffect(() => {
    if (!mounted) return;

    // Layout effect code that requires DOM
    const element = document.getElementById("my-element");
    // ... layout calculations
  }, [mounted]);
}
```

### Issue 3: Concurrent Features Breaking Existing Code

**Problem**: Components not designed for concurrency break.

**Solution**:

```jsx
// Temporarily disable concurrent features for problematic components
import { unstable_noStore } from "next/cache"; // Next.js

function NonConcurrentComponent() {
  unstable_noStore(); // Disable caching for this component

  // Your existing code that doesn't work with concurrency
}

// Use startTransition for controlled concurrency
function SafeComponent() {
  const [isPending, startTransition] = useTransition();

  const handleUpdate = (newData) => {
    startTransition(() => {
      setData(newData);
    });
  };

  return (
    <div>
      {isPending && <div>Updating...</div>}
      <button onClick={() => handleUpdate(data)}>Update</button>
    </div>
  );
}
```

### Issue 4: TypeScript Errors

**Problem**: New React 19 types causing issues.

**Solution**:

```typescript
// Update type definitions
interface MyComponentProps {
  children: React.ReactNode; // More specific than ReactNode
  onChange?: (value: string) => void;
}

// Use proper event types
function MyInput({ onChange }: { onChange?: (value: string) => void }) {
  return (
    <input
      onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
        onChange?.(e.target.value);
      }}
    />
  );
}

// Handle async components
type AsyncComponentProps = {
  data: Promise<DataType>;
};

function AsyncComponent({ data }: AsyncComponentProps) {
  const [resolvedData, setResolvedData] = useState<DataType | null>(null);

  useEffect(() => {
    data.then(setResolvedData);
  }, [data]);

  if (!resolvedData) return <div>Loading...</div>;

  return <div>{resolvedData.name}</div>;
}
```

### Issue 5: Memory Leaks with useOptimistic

**Problem**: Optimistic updates not cleaned up properly.

**Solution**:

```jsx
function SafeOptimisticComponent() {
  const [data, setData] = useState([]);
  const [optimisticData, setOptimisticData] = useOptimistic(data);

  const addItem = useCallback(async (item) => {
    const optimisticItem = { ...item, id: Date.now(), isOptimistic: true };

    setOptimisticData((prev) => [...prev, optimisticItem]);

    try {
      const savedItem = await api.saveItem(item);
      setData((prev) => [...prev, savedItem]);
    } catch (error) {
      // Remove optimistic item
      setOptimisticData((prev) => prev.filter((i) => i.id !== optimisticItem.id));
    }
  }, []);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      // Any cleanup needed for optimistic updates
    };
  }, []);
}
```

### Issue 6: Bundle Size Increase

**Problem**: React 19 bundle is larger.

**Solution**:

```javascript
// Use selective imports
import { useState, useEffect } from "react"; // Instead of import React from 'react'

// Tree shaking configuration
// webpack.config.js
module.exports = {
  optimization: {
    usedExports: true,
    sideEffects: true,
  },
};

// Dynamic imports for large components
const HeavyComponent = lazy(() => import("./HeavyComponent"));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <HeavyComponent />
    </Suspense>
  );
}
```

### Issue 7: Testing Flakiness

**Problem**: Tests failing due to concurrent rendering.

**Solution**:

```jsx
// Use act() for state updates
import { act } from "@testing-library/react";

test("handles concurrent updates", async () => {
  const { result } = renderHook(() => {
    const [count, setCount] = useState(0);
    const [isPending, startTransition] = useTransition();

    const increment = () => {
      startTransition(() => {
        setCount((c) => c + 1);
      });
    };

    return { count, isPending, increment };
  });

  act(() => {
    result.current.increment();
  });

  expect(result.current.isPending).toBe(true);

  await waitFor(() => {
    expect(result.current.count).toBe(1);
    expect(result.current.isPending).toBe(false);
  });
});

// Mock timers for deferred values
test("useDeferredValue with timers", async () => {
  jest.useFakeTimers();

  const { result, rerender } = renderHook(({ value }) => useDeferredValue(value), {
    initialProps: { value: "initial" },
  });

  rerender({ value: "updated" });

  // Fast-forward timers
  act(() => {
    jest.advanceTimersByTime(0);
  });

  expect(result.current).toBe("updated");
});
```

## üìä Migration Checklist

### Pre-Migration ‚úÖ

- [ ] Backup current codebase
- [ ] Check dependency compatibility
- [ ] Review breaking changes documentation
- [ ] Plan rollback strategy
- [ ] Set up monitoring and alerting

### Core Migration ‚úÖ

- [ ] Update React to v19
- [ ] Update React DOM to v19
- [ ] Update TypeScript types
- [ ] Update build tools (Next.js, Vite, etc.)
- [ ] Update ESLint configuration
- [ ] Update testing setup

### Code Updates ‚úÖ

- [ ] Handle StrictMode changes
- [ ] Update error boundaries
- [ ] Adopt useOptimistic where applicable
- [ ] Implement useDeferredValue for performance
- [ ] Use useTransition for non-urgent updates
- [ ] Update component patterns for concurrency
- [ ] Fix hydration mismatches
- [ ] Update TypeScript usage

### Testing & Validation ‚úÖ

- [ ] Update test files
- [ ] Run existing tests
- [ ] Test new features
- [ ] Performance testing
- [ ] Cross-browser testing
- [ ] Accessibility testing
- [ ] Integration testing

### Production Deployment ‚úÖ

- [ ] Build production bundle
- [ ] Test in staging environment
- [ ] Monitor performance metrics
- [ ] Prepare rollback plan
- [ ] Update CI/CD pipelines
- [ ] Update deployment scripts

## üöÄ Post-Migration Benefits

### Performance Improvements

- **Faster Initial Page Loads**: Server Components reduce bundle size
- **Better Responsiveness**: Concurrent rendering prevents UI blocking
- **Improved Caching**: Better cache invalidation strategies
- **Reduced Bundle Size**: Tree shaking and code splitting optimizations

### Developer Experience

- **Better Error Messages**: More detailed error information
- **Improved TypeScript Support**: Better type inference
- **Enhanced Debugging**: Better React DevTools integration
- **Modern Patterns**: Access to latest React features

### User Experience

- **Smoother Interactions**: Optimistic updates feel instant
- **Better Loading States**: useTransition provides loading feedback
- **Reduced Layout Shift**: Better concurrent rendering
- **Improved Accessibility**: Better focus management

## üîÑ Rollback Strategy

If issues arise after migration:

```bash
# Quick rollback to React 18
npm install react@^18.2.0 react-dom@^18.2.0 @types/react@^18.2.0 @types/react-dom@^18.2.0

# Revert specific changes
git revert <commit-hash>

# Or rollback entire migration
git reset --hard <backup-branch>

# For Next.js projects
npm install next@^14.0.0 # Latest stable v14
```

### Gradual Rollback Options

```javascript
// Feature flags for gradual rollback
const REACT_19_FEATURES = {
  useOptimistic: true,
  useDeferredValue: true,
  useTransition: true,
  concurrentRendering: true,
};

// Conditionally enable features
function useConditionalOptimistic(initialValue) {
  return REACT_19_FEATURES.useOptimistic ? useOptimistic(initialValue) : initialValue;
}
```

## üìö Additional Resources

- [React 19 Official Documentation](https://react.dev)
- [React 19 Migration Guide](https://react.dev/blog/2024/04/25/react-19)
- [Next.js 15 Migration Guide](https://nextjs.org/docs/app/building-your-application/upgrading)
- [React Compiler Documentation](https://react.dev/learn/react-compiler)
- [React 19 TypeScript Guide](https://react-typescript-cheatsheet.netlify.app/)

## üéØ Success Metrics

Monitor these after migration:

```javascript
// Performance metrics to track
const successMetrics = {
  // Core Web Vitals
  firstContentfulPaint: true,
  largestContentfulPaint: true,
  firstInputDelay: true,
  cumulativeLayoutShift: true,

  // React-specific metrics
  bundleSize: true,
  runtimeErrors: true,
  hydrationTime: true,
  concurrentRenderingUsage: true,

  // User experience
  timeToInteractive: true,
  userSatisfactionScore: true,
  errorRate: true,
};

// Monitoring setup
function MigrationMonitor() {
  useEffect(() => {
    // Track migration success
    if (typeof window !== "undefined") {
      window.gtag("event", "react_19_migration", {
        event_category: "migration",
        event_label: "successful_upgrade",
        value: 1,
      });
    }
  }, []);

  return null;
}
```

## Conclusion

Migrating to React 19 is a significant upgrade that brings modern React features and improved performance. By following this comprehensive guide, you'll ensure a smooth transition with minimal disruption.

**Key Takeaways:**

1. **Plan Thoroughly**: Backup and test extensively
2. **Migrate Incrementally**: Update dependencies first, then adopt features
3. **Test Everything**: Use the comprehensive checklist
4. **Monitor Performance**: Track metrics before and after
5. **Have a Rollback Plan**: Be prepared to revert if needed
6. **Leverage New Features**: useOptimistic, useDeferredValue, useTransition
7. **Optimize for Production**: Bundle size, performance, monitoring

React 19 represents the future of React development. The new features like Server Components, useOptimistic, and enhanced concurrent rendering will significantly improve both developer experience and application performance.

Start with a small, non-critical part of your application to test the migration process, then gradually roll it out to your entire codebase. Good luck! üöÄ

## üìû Support and Community

- **React Discord**: Join the React community for migration discussions
- **GitHub Issues**: Report bugs and get help from maintainers
- **Stack Overflow**: Search for existing solutions
- **React Blog**: Stay updated with latest React news

Remember, migration is a journey, not a destination. Take it one step at a time, and don't hesitate to ask for help from the community! üéâ

## üîç Pre-Migration Assessment

### Step 1: Check Your Current Setup

```bash
# Check your current React version
npm list react react-dom

# Check for deprecated patterns
npx @next/codemod --help
```

### Step 2: Backup Your Project

```bash
# Create a backup branch
git checkout -b migration-backup
git add .
git commit -m "Backup before React 19 migration"

# Create a new migration branch
git checkout -b react-19-migration
```

### Step 3: Update Dependencies

```bash
# Update React and React DOM
npm install react@latest react-dom@latest

# Update related packages
npm install @types/react@latest @types/react-dom@latest

# Update testing libraries if needed
npm install @testing-library/react@latest @testing-library/jest-dom@latest

# Update build tools
npm install next@latest # if using Next.js
npm install vite@latest # if using Vite
```

## üöÄ Step-by-Step Migration Process

### Phase 1: Core Dependencies Update

#### 1.1 Update package.json

```json
{
  "dependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "next": "^15.0.0" // if applicable
  },
  "devDependencies": {
    "@types/react": "^19.0.0",
    "@types/react-dom": "^19.0.0",
    "typescript": "^5.6.0" // if using TypeScript
  }
}
```

#### 1.2 Install Updates

```bash
npm install
```

#### 1.3 Handle TypeScript Updates

If you're using TypeScript, update your `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["DOM", "DOM.Iterable", "ES6"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  }
}
```

### Phase 2: Handle Breaking Changes

#### 2.1 React.StrictMode Changes

React 19 enables concurrent features by default. Update your root component:

```jsx
// Before (React 18)
import { StrictMode } from "react";

function App() {
  return (
    <StrictMode>
      <MyApp />
    </StrictMode>
  );
}

// After (React 19) - Concurrent features enabled by default
import { StrictMode } from "react";

function App() {
  return (
    <StrictMode>
      <MyApp />
    </StrictMode>
  );
}
```

#### 2.2 useEffect Cleanup Function Changes

React 19 is stricter about cleanup functions:

```jsx
// Before (React 18)
useEffect(() => {
  const timer = setTimeout(() => {
    console.log("Done!");
  }, 1000);

  return () => {
    clearTimeout(timer);
  };
}, []);

// After (React 19) - Same, but stricter enforcement
useEffect(() => {
  const timer = setTimeout(() => {
    console.log("Done!");
  }, 1000);

  return () => {
    clearTimeout(timer);
  };
}, []);
```

#### 2.3 Error Boundary Updates

Error boundaries work the same but with better error information:

```jsx
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // Log error details (React 19 provides more detailed errorInfo)
    console.error("Error caught by boundary:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <div>Something went wrong: {this.state.error.message}</div>;
    }

    return this.props.children;
  }
}
```

### Phase 3: Adopt New Features

#### 3.1 Implement useOptimistic

Replace manual optimistic updates with the new hook:

```jsx
// Before (React 18)
function TodoList() {
  const [todos, setTodos] = useState([]);
  const [isAdding, setIsAdding] = useState(false);

  const addTodo = async (text) => {
    setIsAdding(true);
    const tempId = Date.now();
    setTodos((prev) => [...prev, { id: tempId, text, completed: false }]);

    try {
      const newTodo = await api.addTodo(text);
      setTodos((prev) => prev.map((todo) => (todo.id === tempId ? newTodo : todo)));
    } catch (error) {
      setTodos((prev) => prev.filter((todo) => todo.id !== tempId));
    } finally {
      setIsAdding(false);
    }
  };
}

// After (React 19)
import { useOptimistic } from "react";

function TodoList() {
  const [todos, setTodos] = useState([]);
  const [optimisticTodos, setOptimisticTodos] = useOptimistic(todos);

  const addTodo = async (text) => {
    const optimisticTodo = { id: Date.now(), text, completed: false };

    setOptimisticTodos((prev) => [...prev, optimisticTodo]);

    try {
      const newTodo = await api.addTodo(text);
      setTodos((prev) => [...prev, newTodo]);
    } catch (error) {
      setTodos((prev) => prev.filter((todo) => todo.id !== optimisticTodo.id));
    }
  };
}
```

#### 3.2 Use useDeferredValue for Performance

```jsx
// Before (React 18)
function SearchComponent({ data }) {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState([]);

  useEffect(() => {
    const filtered = data.filter((item) => item.name.toLowerCase().includes(query.toLowerCase()));
    setResults(filtered);
  }, [query, data]);

  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} placeholder="Search..." />
      <ResultsList results={results} />
    </div>
  );
}

// After (React 19)
import { useDeferredValue } from "react";

function SearchComponent({ data }) {
  const [query, setQuery] = useState("");
  const deferredQuery = useDeferredValue(query);

  const results = useMemo(() => {
    return data.filter((item) => item.name.toLowerCase().includes(deferredQuery.toLowerCase()));
  }, [deferredQuery, data]);

  const isStale = query !== deferredQuery;

  return (
    <div>
      <input value={query} onChange={(e) => setQuery(e.target.value)} placeholder="Search..." />
      {isStale && <div>Searching...</div>}
      <ResultsList results={results} />
    </div>
  );
}
```

#### 3.3 Implement useTransition

```jsx
// Before (React 18)
function TabComponent({ tabs }) {
  const [activeTab, setActiveTab] = useState(0);
  const [isLoading, setIsLoading] = useState(false);

  const switchTab = async (index) => {
    setIsLoading(true);
    await new Promise((resolve) => setTimeout(resolve, 100)); // Simulate loading
    setActiveTab(index);
    setIsLoading(false);
  };

  return (
    <div>
      {tabs.map((tab, index) => (
        <button key={index} onClick={() => switchTab(index)} disabled={isLoading}>
          {tab.title}
        </button>
      ))}
      {isLoading ? <div>Loading...</div> : <TabContent content={tabs[activeTab].content} />}
    </div>
  );
}

// After (React 19)
import { useTransition } from "react";

function TabComponent({ tabs }) {
  const [activeTab, setActiveTab] = useState(0);
  const [isPending, startTransition] = useTransition();

  const switchTab = (index) => {
    startTransition(() => {
      setActiveTab(index);
    });
  };

  return (
    <div>
      {tabs.map((tab, index) => (
        <button key={index} onClick={() => switchTab(index)} disabled={isPending}>
          {tab.title}
        </button>
      ))}
      {isPending ? <div>Loading...</div> : <TabContent content={tabs[activeTab].content} />}
    </div>
  );
}
```

### Phase 4: Update Testing

#### 4.1 Update Test Files

```jsx
// Update test imports
import { render, screen, waitFor } from "@testing-library/react";
import { useOptimistic, useDeferredValue } from "react";

// Test useOptimistic
test("optimistic updates work correctly", async () => {
  const TestComponent = () => {
    const [state, setState] = useState("initial");
    const [optimisticState, setOptimisticState] = useOptimistic(state);

    return (
      <div>
        <div data-testid="optimistic">{optimisticState}</div>
        <button onClick={() => setOptimisticState("updated")}>Update</button>
      </div>
    );
  };

  render(<TestComponent />);
  expect(screen.getByTestId("optimistic")).toHaveTextContent("initial");

  fireEvent.click(screen.getByText("Update"));
  expect(screen.getByTestId("optimistic")).toHaveTextContent("updated");
});

// Test useDeferredValue
test("deferred value updates correctly", async () => {
  const TestComponent = ({ value }) => {
    const deferredValue = useDeferredValue(value);
    return <div data-testid="deferred">{deferredValue}</div>;
  };

  const { rerender } = render(<TestComponent value="initial" />);
  expect(screen.getByTestId("deferred")).toHaveTextContent("initial");

  rerender(<TestComponent value="updated" />);
  // Deferred value might still be old initially
  await waitFor(() => {
    expect(screen.getByTestId("deferred")).toHaveTextContent("updated");
  });
});
```

#### 4.2 Update Jest Configuration

```javascript
// jest.config.js
module.exports = {
  testEnvironment: "jsdom",
  setupFilesAfterEnv: ["<rootDir>/src/setupTests.js"],
  testMatch: [
    "<rootDir>/src/**/__tests__/**/*.{js,jsx,ts,tsx}",
    "<rootDir>/src/**/*.{test,spec}.{js,jsx,ts,tsx}",
  ],
  moduleNameMapping: {
    "^@/(.*)$": "<rootDir>/src/$1",
  },
};
```

### Phase 5: Performance Optimization

#### 5.1 Enable React Compiler (Experimental)

```jsx
// next.config.js (for Next.js)
module.exports = {
  experimental: {
    reactCompiler: true,
  },
};

// For Vite
// vite.config.js
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
  plugins: [
    react({
      babel: {
        plugins: [["babel-plugin-react-compiler", {}]],
      },
    }),
  ],
});
```

#### 5.2 Optimize Bundle Size

```bash
# Analyze bundle size
npm install --save-dev webpack-bundle-analyzer
npx webpack-bundle-analyzer dist/static/js/*.js
```

#### 5.3 Update Performance Monitoring

```jsx
// Add performance monitoring
import { useEffect } from "react";

function PerformanceMonitor() {
  useEffect(() => {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === "measure") {
          console.log(`${entry.name}: ${entry.duration}ms`);
        }
      }
    });

    observer.observe({ entryTypes: ["measure"] });

    return () => observer.disconnect();
  }, []);

  return null;
}
```

## üîß Troubleshooting Common Issues

### Issue 1: Hydration Mismatches

**Problem**: Server and client rendering don't match.

**Solution**:

```jsx
// Use useEffect for client-only code
function ClientOnlyComponent() {
  const [isClient, setIsClient] = useState(false);

  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return <div>Loading...</div>; // or skeleton
  }

  return <div>Client-only content</div>;
}
```

### Issue 2: useLayoutEffect Warnings

**Problem**: useLayoutEffect doesn't work on server.

**Solution**:

```jsx
import { useEffect, useLayoutEffect } from "react";

function useIsomorphicLayoutEffect() {
  return typeof window !== "undefined" ? useLayoutEffect : useEffect;
}

function MyComponent() {
  const isomorphicLayoutEffect = useIsomorphicLayoutEffect();

  isomorphicLayoutEffect(() => {
    // Your layout effect code
  }, []);
}
```

### Issue 3: Concurrent Features Breaking Existing Code

**Problem**: Components not designed for concurrency break.

**Solution**:

```jsx
// Temporarily disable concurrent features
import { unstable_noStore } from "next/cache"; // Next.js

function NonConcurrentComponent() {
  unstable_noStore(); // Disable caching for this component

  // Your existing code that doesn't work with concurrency
}
```

### Issue 4: TypeScript Errors

**Problem**: New React 19 types causing issues.

**Solution**:

```typescript
// Update type definitions
interface MyComponentProps {
  children: React.ReactNode; // More specific than ReactNode
  onChange?: (value: string) => void;
}

// Use proper event types
function MyInput({ onChange }: { onChange?: (value: string) => void }) {
  return (
    <input
      onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
        onChange?.(e.target.value);
      }}
    />
  );
}
```

## üìä Migration Checklist

### Pre-Migration ‚úÖ

- [ ] Backup current codebase
- [ ] Check dependency compatibility
- [ ] Review breaking changes documentation
- [ ] Plan rollback strategy

### Core Migration ‚úÖ

- [ ] Update React to v19
- [ ] Update React DOM to v19
- [ ] Update TypeScript types
- [ ] Update build tools (Next.js, Vite, etc.)

### Code Updates ‚úÖ

- [ ] Handle StrictMode changes
- [ ] Update error boundaries
- [ ] Adopt useOptimistic where applicable
- [ ] Implement useDeferredValue for performance
- [ ] Use useTransition for non-urgent updates

### Testing & Validation ‚úÖ

- [ ] Update test files
- [ ] Run existing tests
- [ ] Test new features
- [ ] Performance testing
- [ ] Cross-browser testing

### Production Deployment ‚úÖ

- [ ] Build production bundle
- [ ] Test in staging environment
- [ ] Monitor performance metrics
- [ ] Prepare rollback plan

## üöÄ Post-Migration Benefits

### Performance Improvements

- **Faster Initial Page Loads**: Server Components reduce bundle size
- **Better Responsiveness**: Concurrent rendering prevents UI blocking
- **Improved Caching**: Better cache invalidation strategies

### Developer Experience

- **Better Error Messages**: More detailed error information
- **Improved TypeScript Support**: Better type inference
- **Enhanced Debugging**: Better React DevTools integration

### User Experience

- **Smoother Interactions**: Optimistic updates feel instant
- **Better Loading States**: useTransition provides loading feedback
- **Reduced Layout Shift**: Better concurrent rendering

## üîÑ Rollback Strategy

If issues arise after migration:

```bash
# Quick rollback to React 18
npm install react@^18.2.0 react-dom@^18.2.0

# Revert specific changes
git revert <commit-hash>

# Or rollback entire migration
git reset --hard <backup-branch>
```

## üìö Additional Resources

- [React 19 Official Documentation](https://react.dev)
- [React 19 Migration Guide](https://react.dev/blog/2024/04/25/react-19)
- [Next.js 15 Migration Guide](https://nextjs.org/docs/app/building-your-application/upgrading)
- [React Compiler Documentation](https://react.dev/learn/react-compiler)

## üéØ Success Metrics

Monitor these after migration:

```javascript
// Performance metrics to track
const metrics = {
  firstContentfulPaint: true,
  largestContentfulPaint: true,
  firstInputDelay: true,
  cumulativeLayoutShift: true,
  bundleSize: true,
  runtimeErrors: true,
};
```

## Conclusion

Migrating to React 19 is a significant upgrade that brings modern React features and improved performance. By following this guide step by step, you'll ensure a smooth transition with minimal disruption.

**Key Takeaways:**

1. **Plan Thoroughly**: Backup and test extensively
2. **Migrate Incrementally**: Update dependencies first, then adopt features
3. **Test Everything**: Use the migration checklist
4. **Monitor Performance**: Track metrics before and after
5. **Have a Rollback Plan**: Be prepared to revert if needed

React 19 represents the future of React development. The new features like Server Components, useOptimistic, and enhanced concurrent rendering will significantly improve both developer experience and application performance.

Start with a small, non-critical part of your application to test the migration process, then gradually roll it out to your entire codebase. Good luck! üöÄ

## üè¢ Enterprise Migration Strategies

### Large Codebase Migration

For enterprise applications with large codebases:

```javascript
// Feature flags for gradual rollout
const REACT_19_FEATURES = {
  useOptimistic: process.env.REACT_19_OPTIMISTIC === "true",
  useDeferredValue: process.env.REACT_19_DEFERRED === "true",
  useTransition: process.env.REACT_19_TRANSITION === "true",
  concurrentRendering: process.env.REACT_19_CONCURRENT === "true",
};

// Conditional hook usage
function useConditionalOptimistic(initialValue) {
  return REACT_19_FEATURES.useOptimistic ? useOptimistic(initialValue) : initialValue;
}

// Gradual component migration
function LegacyComponent() {
  // Old implementation
  return <div>Legacy Component</div>;
}

function React19Component() {
  // New implementation with React 19 features
  return <div>React 19 Component</div>;
}

// Feature flag component
function FeatureFlaggedComponent() {
  return REACT_19_FEATURES.concurrentRendering ? <React19Component /> : <LegacyComponent />;
}
```

### Micro-Frontend Migration

```javascript
// Module federation configuration
// webpack.config.js
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: "host",
      remotes: {
        app1: "app1@http://localhost:3001/remoteEntry.js",
        app2: "app2@http://localhost:3002/remoteEntry.js",
      },
      shared: {
        react: {
          singleton: true,
          requiredVersion: "^19.0.0",
        },
        "react-dom": {
          singleton: true,
          requiredVersion: "^19.0.0",
        },
      },
    }),
  ],
};
```

### CI/CD Pipeline Updates

```yaml
# .github/workflows/react-19-migration.yml
name: React 19 Migration Tests

on:
  pull_request:
    branches: [main, develop]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        react-version: ["18.2.0", "19.0.0-rc.0"]

    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm ci

      - name: Install specific React version
        run: npm install react@${{ matrix.react-version }} react-dom@${{ matrix.react-version }}

      - name: Run tests
        run: npm test

      - name: Run E2E tests
        run: npm run test:e2e
```

## üîß Advanced Troubleshooting

### Issue 8: Third-Party Library Compatibility

**Problem**: Third-party libraries not compatible with React 19.

**Solution**:

```javascript
// Check library compatibility
npm outdated

// Update or replace incompatible libraries
npm install @mui/material@latest // If using Material-UI
npm install react-router-dom@latest // If using React Router

// For libraries that can't be updated immediately
// Create compatibility wrappers
function LegacyLibraryWrapper(props) {
  const [mounted, setMounted] = useState(false);

  useEffect(() => {
    setMounted(true);
  }, []);

  if (!mounted) {
    return <div>Loading...</div>;
  }

  return <LegacyLibrary {...props} />;
}
```

### Issue 9: Server-Side Rendering Issues

**Problem**: SSR not working properly with React 19.

**Solution**:

```jsx
// Fix SSR with useOptimistic
function ServerCompatibleComponent({ initialData }) {
  const [data, setData] = useState(initialData);
  const [optimisticData, setOptimisticData] = useOptimistic(data);

  // Only use optimistic updates on client
  useEffect(() => {
    if (typeof window !== "undefined") {
      setOptimisticData(data);
    }
  }, [data]);

  return <div>{optimisticData}</div>;
}

// Next.js specific fixes
// next.config.js
module.exports = {
  experimental: {
    serverComponentsExternalPackages: ["some-package"],
    serverActions: true,
  },
};
```

### Issue 10: Performance Regressions

**Problem**: Migration causes performance issues.

**Solution**:

```jsx
// Performance monitoring
function PerformanceProfiler({ children }) {
  const [metrics, setMetrics] = useState({});

  useEffect(() => {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const newMetrics = {};

      entries.forEach((entry) => {
        if (entry.entryType === 'measure') {
          newMetrics[entry.name] = entry.duration;
        }
      });

      setMetrics(prev => ({ ...prev, ...newMetrics }));
    });

    observer.observe({ entryTypes: ['measure'] });

    return () => observer.disconnect();
  }, []);

  return (
    <div>
      <div style={{ display: 'none' }}>
        Performance Metrics: {JSON.stringify(metrics)}
      </div>
      {children}
    </div>
  );
}

// Bundle analyzer
// Add to package.json scripts
{
  "scripts": {
    "analyze": "webpack-bundle-analyzer dist/static/js/*.js"
  }
}
```

## ‚ùì Frequently Asked Questions

### Q: Should I migrate all at once or gradually?

**A**: For most applications, gradual migration is recommended. Start with:

1. Update dependencies
2. Fix breaking changes
3. Adopt new features incrementally
4. Test thoroughly at each step

### Q: What if my app breaks after migration?

**A**: Have a rollback plan ready:

```bash
# Quick rollback
git checkout react-18-backup
npm install
npm run build
```

### Q: Are there any features I should avoid initially?

**A**: Start with stable features:

- ‚úÖ useOptimistic
- ‚úÖ useDeferredValue
- ‚úÖ useTransition
- ‚ö†Ô∏è React Compiler (still experimental)
- ‚ö†Ô∏è Server Components (if not using Next.js 15)

### Q: How do I handle TypeScript migration?

**A**: Update gradually:

```typescript
// Phase 1: Update React types
npm install @types/react@latest @types/react-dom@latest

// Phase 2: Fix type errors
// Phase 3: Enable strict mode
// Phase 4: Add advanced types
```

### Q: What's the impact on bundle size?

**A**: React 19 is similar in size to React 18, but offers better tree-shaking:

- Use selective imports: `import { useState } from 'react'`
- Enable tree-shaking in your bundler
- Consider dynamic imports for large components

### Q: How do I test React 19 features?

**A**: Use comprehensive testing:

```jsx
// Test concurrent features
test("concurrent rendering works", async () => {
  const { result } = renderHook(() => {
    const [isPending, startTransition] = useTransition();
    // Test implementation
  });
});
```

### Q: Can I use React 19 with older versions of other libraries?

**A**: Generally yes, but test thoroughly:

- React Router v6+ works well
- Most UI libraries are compatible
- Testing libraries need updates
- Build tools should be updated

## üìä Migration Analytics & Monitoring

### Track Migration Success

```javascript
// Migration tracking
function MigrationTracker() {
  useEffect(() => {
    // Track migration events
    const events = [
      "react_19_migration_started",
      "react_19_dependencies_updated",
      "react_19_breaking_changes_fixed",
      "react_19_features_adopted",
      "react_19_testing_completed",
      "react_19_production_deployed",
    ];

    events.forEach((event) => {
      if (typeof window !== "undefined" && window.gtag) {
        window.gtag("event", event, {
          event_category: "migration",
          event_label: "react_19",
        });
      }
    });
  }, []);

  return null;
}

// Performance comparison
function PerformanceComparison() {
  const [before, setBefore] = useState({});
  const [after, setAfter] = useState({});

  useEffect(() => {
    // Collect performance metrics
    if (typeof window !== "undefined" && window.performance) {
      const navigation = window.performance.getEntriesByType("navigation")[0];
      const paint = window.performance.getEntriesByType("paint");

      setAfter({
        domContentLoaded:
          navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
        loadComplete: navigation.loadEventEnd - navigation.loadEventStart,
        firstPaint: paint.find((p) => p.name === "first-paint")?.startTime,
        firstContentfulPaint: paint.find((p) => p.name === "first-contentful-paint")?.startTime,
      });
    }
  }, []);

  return (
    <div>
      <h3>Migration Performance Impact</h3>
      <div>DOM Content Loaded: {after.domContentLoaded}ms</div>
      <div>Load Complete: {after.loadComplete}ms</div>
      <div>First Paint: {after.firstPaint}ms</div>
      <div>First Contentful Paint: {after.firstContentfulPaint}ms</div>
    </div>
  );
}
```

## üöÄ Post-Migration Optimization

### Advanced Performance Techniques

```jsx
// Code splitting with React 19
const AdminPanel = lazy(() => import("./AdminPanel"));
const UserDashboard = lazy(() => import("./UserDashboard"));

function App() {
  const [userRole, setUserRole] = useState(null);

  return (
    <Suspense fallback={<div>Loading...</div>}>
      {userRole === "admin" ? <AdminPanel /> : <UserDashboard />}
    </Suspense>
  );
}

// Preloading critical resources
function usePreload() {
  useEffect(() => {
    // Preload critical components
    import("./CriticalComponent");
    // Preload critical data
    fetch("/api/critical-data");
  }, []);
}

// Service worker for caching
// public/sw.js
self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open("react-19-cache").then((cache) => {
      return cache.addAll(["/", "/static/js/bundle.js", "/static/css/main.css"]);
    })
  );
});
```

### Monitoring & Alerting

```javascript
// Error tracking with React 19
function ErrorTracker() {
  useEffect(() => {
    const handleError = (error, errorInfo) => {
      // Send to error tracking service
      if (typeof window !== "undefined" && window.Sentry) {
        window.Sentry.captureException(error, {
          extra: {
            componentStack: errorInfo.componentStack,
            reactVersion: "19.0.0",
          },
        });
      }
    };

    window.addEventListener("error", handleError);
    window.addEventListener("unhandledrejection", handleError);

    return () => {
      window.removeEventListener("error", handleError);
      window.removeEventListener("unhandledrejection", handleError);
    };
  }, []);

  return null;
}

// Performance monitoring
function PerformanceMonitor() {
  useEffect(() => {
    if (typeof window !== "undefined" && window.performance) {
      // Monitor Core Web Vitals
      import("web-vitals").then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
        getCLS(console.log);
        getFID(console.log);
        getFCP(console.log);
        getLCP(console.log);
        getTTFB(console.log);
      });
    }
  }, []);

  return null;
}
```

## üìö Extended Resources

- [React 19 Official Documentation](https://react.dev)
- [React 19 Migration Guide](https://react.dev/blog/2024/04/25/react-19)
- [Next.js 15 Migration Guide](https://nextjs.org/docs/app/building-your-application/upgrading)
- [React Compiler Documentation](https://react.dev/learn/react-compiler)
- [React 19 TypeScript Guide](https://react-typescript-cheatsheet.netlify.app/)
- [React 19 Performance Guide](https://web.dev/react-19)
- [React 19 Concurrent Features](https://github.com/reactjs/rfcs/pull/21)
- [React 19 Server Components RFC](https://github.com/reactjs/rfcs/pull/188)

## üìû Support and Community

- **React Discord**: Join the React community for migration discussions
- **GitHub Issues**: Report bugs and get help from maintainers
- **Stack Overflow**: Search for existing solutions
- **React Blog**: Stay updated with latest React news
- **Reddit r/reactjs**: Community discussions and help
- **Dev.to React Tag**: Articles and tutorials from community

Remember, migration is a journey, not a destination. Take it one step at a time, and don't hesitate to ask for help from the community! üéâ

---

_This comprehensive React 19 Migration Guide has been crafted to be your complete companion for upgrading from React 18. Whether you're working on a small project or a large enterprise application, this guide provides the knowledge and practical examples you need for a successful migration. Stay updated with the latest React developments and happy coding!_ üöÄ
