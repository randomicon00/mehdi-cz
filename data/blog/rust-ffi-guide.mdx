---
title: "Rust FFI Guide: A Comprehensive Guide to Interfacing Rust with C"
date: "2024-10-18"
tags: ["rust", "ffi", "c programming", "systems programming", "interoperability"]
draft: true
summary: "Explore how to use Rust's Foreign Function Interface (FFI) to integrate Rust with C, including detailed type mappings, memory management, and practical examples."
---

```rust
use std::ffi::CStr;
use std::net::{IpAddr, Ipv4Addr};
use std::ptr;
use libc::{c_char, c_int, c_uchar, c_void};
use std::mem::size_of;

/// Link to the external C `libpcap` library for FFI.
#[link(name = "pcap")]
extern "C" {
    fn pcap_open_live(
        device: *const c_char,
        snaplen: c_int,
        promisc: c_int,
        to_ms: c_int,
        errbuf: *mut c_char,
    ) -> *mut c_void;

    fn pcap_loop(
        handle: *mut c_void,
        count: c_int,
        callback: extern "C" fn(*mut c_uchar, *const pcap_pkthdr, *const c_uchar),
        user: *mut c_uchar,
    ) -> c_int;

    fn pcap_close(handle: *mut c_void);

    fn pcap_pkthdr() -> *const c_void;
}

/// Struct representing the packet header.
#[repr(C)]
struct pcap_pkthdr {
    ts: libc::timeval,
    caplen: u32,
    len: u32,
}

/// Capture settings for pcap.
const SNAPLEN: c_int = 65535;
const PROMISC: c_int = 1;
const TO_MS: c_int = 1000;

/// Parses Ethernet, IP, and TCP headers from packet data.
extern "C" fn packet_handler(_user: *mut c_uchar, header: *const pcap_pkthdr, packet: *const c_uchar) {
    let header = unsafe { &*header };
    println!("Captured packet with length: {} bytes", header.len);

    // Convert packet pointer to slice for easier processing
    let packet = unsafe { std::slice::from_raw_parts(packet, header.caplen as usize) };

    // Parse the Ethernet header
    if packet.len() < 14 {
        println!("Packet too short for Ethernet header");
        return;
    }
    let eth_type = u16::from_be_bytes([packet[12], packet[13]]);
    println!("Ethernet Type: {:#X}", eth_type);

    // Only proceed if it's an IP packet (0x0800)
    if eth_type != 0x0800 {
        println!("Not an IP packet");
        return;
    }

    // Parse the IP header
    let ip_header_start = 14; // Ethernet header length
    let ip_header = &packet[ip_header_start..ip_header_start + 20];

    let version = ip_header[0] >> 4;
    let ihl = (ip_header[0] & 0x0F) * 4;
    let total_length = u16::from_be_bytes([ip_header[2], ip_header[3]]);
    let protocol = ip_header[9];
    let src_ip = Ipv4Addr::new(ip_header[12], ip_header[13], ip_header[14], ip_header[15]);
    let dst_ip = Ipv4Addr::new(ip_header[16], ip_header[17], ip_header[18], ip_header[19]);

    println!("IP Version: {}", version);
    println!("IP Header Length: {} bytes", ihl);
    println!("Total Length: {} bytes", total_length);
    println!("Protocol: {}", protocol);
    println!("Source IP: {}", src_ip);
    println!("Destination IP: {}", dst_ip);

    // Parse TCP or UDP header based on protocol
    match protocol {
        6 => parse_tcp_header(&packet[ip_header_start + ihl as usize..]),
        17 => parse_udp_header(&packet[ip_header_start + ihl as usize..]),
        _ => println!("Unsupported protocol"),
    }
}

/// Parses and prints TCP header fields.
fn parse_tcp_header(packet: &[u8]) {
    if packet.len() < 20 {
        println!("Packet too short for TCP header");
        return;
    }

    let src_port = u16::from_be_bytes([packet[0], packet[1]]);
    let dst_port = u16::from_be_bytes([packet[2], packet[3]]);
    let sequence = u32::from_be_bytes([packet[4], packet[5], packet[6], packet[7]]);
    let ack_number = u32::from_be_bytes([packet[8], packet[9], packet[10], packet[11]]);
    let data_offset = (packet[12] >> 4) * 4;

    println!("TCP Header:");
    println!("Source Port: {}", src_port);
    println!("Destination Port: {}", dst_port);
    println!("Sequence Number: {}", sequence);
    println!("Acknowledgment Number: {}", ack_number);
    println!("Data Offset: {} bytes", data_offset);
}

/// Parses and prints UDP header fields.
fn parse_udp_header(packet: &[u8]) {
    if packet.len() < 8 {
        println!("Packet too short for UDP header");
        return;
    }

    let src_port = u16::from_be_bytes([packet[0], packet[1]]);
    let dst_port = u16::from_be_bytes([packet[2], packet[3]]);
    let length = u16::from_be_bytes([packet[4], packet[5]]);

    println!("UDP Header:");
    println!("Source Port: {}", src_port);
    println!("Destination Port: {}", dst_port);
    println!("Length: {} bytes", length);
}

fn main() {
    // Specify the network device for packet capture (e.g., "eth0" on Linux).
    let device = std::ffi::CString::new("eth0").expect("Failed to create CString");
    let mut errbuf = vec![0 as c_char; 256];

    // Open the capture handle with `pcap_open_live`.
    let handle = unsafe { pcap_open_live(device.as_ptr(), SNAPLEN, PROMISC, TO_MS, errbuf.as_mut_ptr()) };
    if handle.is_null() {
        let err = unsafe { CStr::from_ptr(errbuf.as_ptr()) }.to_string_lossy();
        eprintln!("Error opening device: {}", err);
        return;
    }

    println!("Starting packet capture on device: {}", device.to_str().unwrap());

    // Start capturing packets in a loop.
    unsafe {
        pcap_loop(handle, -1, packet_handler, ptr::null_mut());
    }

    // Clean up by closing the handle.
    unsafe {
        pcap_close(handle);
    }
}
```

| **Rust Type**                       | **Equivalent C Type**             | **Description / Notes**                                                                                             |
| ----------------------------------- | --------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| `i8`                                | `int8_t` / `char`                 | Signed 8-bit integer, often maps to `char` in C.                                                                    |
| `u8`                                | `uint8_t` / `unsigned char`       | Unsigned 8-bit integer.                                                                                             |
| `i16`                               | `int16_t`                         | Signed 16-bit integer, typically `short`.                                                                           |
| `u16`                               | `uint16_t`                        | Unsigned 16-bit integer.                                                                                            |
| `i32`                               | `int32_t` / `int`                 | Signed 32-bit integer, equivalent to C’s `int` on most platforms.                                                   |
| `u32`                               | `uint32_t` / `unsigned int`       | Unsigned 32-bit integer, equivalent to `unsigned int`.                                                              |
| `i64`                               | `int64_t` / `long long`           | Signed 64-bit integer; often maps to C `long long` on most systems.                                                 |
| `u64`                               | `uint64_t` / `unsigned long long` | Unsigned 64-bit integer.                                                                                            |
| `isize`                             | `intptr_t`                        | Signed integer with platform-dependent size (32 or 64-bit depending on architecture).                               |
| `usize`                             | `uintptr_t`                       | Unsigned version of `isize`, typically used for sizes and indexing.                                                 |
| `f32`                               | `float`                           | 32-bit floating-point number.                                                                                       |
| `f64`                               | `double`                          | 64-bit floating-point number.                                                                                       |
| `bool`                              | `_Bool` / `int`                   | Rust `bool` maps to `_Bool` in C99; can use `int` (0 for false, 1 for true) in older standards.                     |
| `char`                              | `char`                            | Rust `char` is a Unicode scalar value, so avoid direct mapping; C `char` is 1 byte (not equivalent to Rust `char`). |
| `c_void`                            | `void`                            | Used for FFI to represent a void pointer (`*mut c_void` / `*const c_void`).                                         |
| `c_char`                            | `char`                            | Typically represents single-byte characters; use `CString` or `CStr` for strings.                                   |
| `c_schar`                           | `signed char`                     | Signed 1-byte integer.                                                                                              |
| `c_uchar`                           | `unsigned char`                   | Unsigned 1-byte integer.                                                                                            |
| `c_short`                           | `short`                           | Signed 16-bit integer.                                                                                              |
| `c_ushort`                          | `unsigned short`                  | Unsigned 16-bit integer.                                                                                            |
| `c_int`                             | `int`                             | Platform-dependent, typically a 32-bit signed integer.                                                              |
| `c_uint`                            | `unsigned int`                    | Platform-dependent, typically a 32-bit unsigned integer.                                                            |
| `c_long`                            | `long`                            | Signed integer, size can vary by platform (32 or 64-bit depending on system).                                       |
| `c_ulong`                           | `unsigned long`                   | Unsigned integer, size can vary by platform (32 or 64-bit depending on system).                                     |
| `c_longlong`                        | `long long`                       | 64-bit signed integer.                                                                                              |
| `c_ulonglong`                       | `unsigned long long`              | 64-bit unsigned integer.                                                                                            |
| `c_float`                           | `float`                           | 32-bit floating-point number.                                                                                       |
| `c_double`                          | `double`                          | 64-bit floating-point number.                                                                                       |
| `*const T`                          | `const T*`                        | Immutable pointer to data of type `T`.                                                                              |
| `*mut T`                            | `T*`                              | Mutable pointer to data of type `T`; requires `unsafe` to dereference in Rust.                                      |
| `Option<&T>`                        | `T*`                              | Nullable pointer; use `std::ptr::null()` for `None`.                                                                |
| `Option<&mut T>`                    | `T*`                              | Same as above, but for mutable pointers.                                                                            |
| `&T`                                | `const T*`                        | Immutable reference, passed as const pointer in C but must follow Rust’s borrowing rules.                           |
| `&mut T`                            | `T*`                              | Mutable reference, passed as mutable pointer in C.                                                                  |
| `CString`                           | `const char*`                     | Rust’s C-compatible string for passing strings to C functions.                                                      |
| `&CStr`                             | `const char*`                     | C-compatible reference to a C string (`CStr` provides safe access to `const char*`).                                |
| `Box<T>`                            | `T*`                              | Rust heap-allocated type; requires `Box::into_raw` and `Box::from_raw` for FFI.                                     |
| `fn()` or `extern "C" fn()`         | `void (*)(void)`                  | Function pointers; use `extern "C" fn()` for FFI compatibility.                                                     |
| `extern "C" fn(a: T1, b: T2) -> T3` | `T3 (*)(T1, T2)`                  | Function pointers with arguments and return type; use `extern "C" fn()` for compatibility.                          |
| `[T; N]`                            | `T[N]`                            | Fixed-size arrays; pass by pointer or reference to work with C arrays.                                              |
| `struct Name { ... }`               | `struct Name { ... }`             | Use `#[repr(C)]` to ensure struct layout matches C; required for FFI compatibility.                                 |
| `enum Name { ... }`                 | `enum Name { ... }`               | Use `#[repr(C)]` for Rust enums to align with C enums, especially if they’re simple integer enums.                  |
| `Result<T, E>`                      | N/A                               | Rust’s `Result` is not FFI-compatible; replace with error codes or other C-friendly error-handling conventions.     |
